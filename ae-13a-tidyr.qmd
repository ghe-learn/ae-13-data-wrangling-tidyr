---
title: "Untitled"
format: html
editor: source
editor_options: 
  chunk_output_type: console
bibliography: references.bib
---


```{r}
library(tidyverse)
library(lubridate)
```


# (Atomic) Vectors

Atomic vectors, of which there are six types: logical, integer, double, character, complex, and raw. 

Integer and double vectors are collectively known as numeric vectors.

- lgl: logical
- int: integer
- dbl: double
- chr: character

```{r}

glimpse(starwars)

```

## Types of atomic vectors

```{r}

vector_lgl <- c(TRUE, TRUE, FALSE)
typeof(vector_lgl)

vector_chr <- c("large", "small", "medium")
typeof(vector_chr)

vector_dbl <- c(192, 118.5, 162.5)
typeof(vector_dbl)

vector_int <- c(1L, 3L, 6L, 6L)
typeof(vector_int)

```

## Explicit vector coercion

```{r}

vector_num <- as.numeric(vector_lgl)
typeof(vector_num) 

vector_fct <- factor(vector_chr, levels = c("small", "medium", "large"))

```

## Augmented vectors 

Vectors can also contain arbitrary additional metadata in the form of attributes. These attributes are used to create augmented vectors which build on additional behaviour. There are three important types of augmented vector:

- Factors are built on top of integer vectors.
- Dates and date-times are built on top of numeric vectors.
- Data frames and tibbles are built on top of lists.

```{r}

typeof(vector_fct)
attributes(vector_fct)
as.integer(vector_fct)

vector_date_chr <- "19.05.2022"

typeof(date_chr)

vector_date_date <- lubridate::dmy(vector_date_chr)

typeof(vector_date_date)

as.double(vector_date_date)

attributes(vector_date_date)

lubridate::as_date("1970-01-03") %>% 
  as.double()

tib_data <- tibble(
  vector_chr,
  vector_fct,
  vector_dbl,
  vector_date_date,
) 

tib_data %>% 
  mutate(month = month(vector_date_date, 
                       label = TRUE, 
                       abbr = FALSE, 
                       locale = "de_CH.UTF-8"))

```

# Data tidying

```{r}

# Data source: https://github.com/rbtl-fs22/research-project-template-disposa-liz/blob/main/data/raw_data/rbtl_fs22_waste_composition_bellevue.csv

waste_data <- read_csv("data/waste-characterisation-disposa-liz.csv")

```

### tidyr::pivot_longer()

```{r}

waste_data_long <- waste_data %>% 
  select(number, starts_with("weight")) %>% 
  rename_with(~str_remove(.x, "weight_")) %>% 
  select(-total) %>% 
  pivot_longer(cols = !number,
              names_to = "waste_category",
              values_to = "weight")

```

- separate()
- drop_na()
- replace_na()
- fill()

## Gapminder

The following exercise is taken from @naupaka_zimmerman_2019_3265164. 

```{r}

library(gapminder)

gapminder_wide <- read_csv("https://raw.githubusercontent.com/swcarpentry/r-novice-gapminder/main/data/gapminder_wide.csv")

```

```{r}
gapminder

gapminder_wide 
glimpse(gapminder_wide)
```


```{r}

gapminder_wide %>% 
  pivot_longer(cols = gdpPercap_1952:pop_2007,
               names_to = "obstype_year",
               values_to = "obs_value") 

# can we calculate the mean life expectancy per country and year?

# Now obstype_year actually contains 2 pieces of information, the observation 
# type (pop,lifeExp, or gdpPercap) and the year. We can use the separate() 
# function to split the character strings into multiple variables

gapminder_long <- gapminder_wide %>% 
  pivot_longer(cols = gdpPercap_1952:pop_2007,
               names_to = "obstype_year",
               values_to = "obs_value") %>% 
  separate(col = obstype_year, into = c("obs_type", "year"), sep = "_") %>% 
  mutate(year = as.integer(year))

```

**Your turn**

Using `gapminder_long`, calculate the mean life expectancy, population, and gdpPercap for each continent. **Hint:** use the `group_by()` and `summarize()` functions we learned in the `dplyr` lesson.

```{r}

gapminder_long %>% 
  group_by(continent, obs_type) %>% 
  summarise(means = mean(obs_value))

```

```{r}

gapminder_normal <- gapminder_long %>% 
  pivot_wider(names_from = obs_type,
              values_from = obs_value) %>% 
  select(country, continent, year, lifeExp, pop, gdpPercap) %>% 
  arrange(country, year)

all.equal(gapminder, gapminder_normal)

```

# Reference

